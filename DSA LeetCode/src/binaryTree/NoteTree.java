package binaryTree;

public class NoteTree {
    /**
     * 满二叉树（Full binary tree)：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树,
     * 如果有k层，节点书为 2**k-1
     * 完全二叉树(complete binary tree)：every node is either a leaf or has two children.国内对于完全二叉树的定义事除了最后一行，其他都是满二叉树
     * perfect binary tree，和满二叉树一样定义，所以满二叉树可以叫FBT或者PBT
     * 上面的树全部没有数值
     */

    /**
     * 二叉搜索树，Binary search tree， 有数值，数值规则为
     * 1.若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。
     * 2. 若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。
     * 3.任意结点的左、右子树也分别为二叉搜索树。
     */

    /**
     * 平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，
     * 且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
     */

    /**
     * 二叉树可以用数组或者链式表达
     * 如果是数组
     * 父节点的左子节点在数组中的位置是2*i+1 右子节点是2*i+2
     * {a, b, c, d, e, f, g, h, i, j, k, l}
     */

    /**
     * 还可以分深度遍历和广度遍历
     * 深度遍历：先往下走，遇到没有子节点的情况，再回退，一般使用栈来实现
     * 深度遍历分前序，后序，中序遍历
     * 广度遍历：一层一层的遍历（层次遍历），一般使用队列来实现
     */

    /**
     * 写递归三部曲：
     * 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
     * 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
     * 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。
     */

    /**
     * 二叉搜索树是一个有序树：
     * 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
     * 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
     * 它的左、右子树也分别为二叉搜索树
     */
}
